; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\obj\usart.o --asm_dir=.\ --list_dir=.\ --depend=..\obj\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\HARDWARE\LED -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\STM32F10x_FWLib\inc -I..\CORE -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\IAP -I..\HARDWARE\STMFLASH -I..\HARDWARE\LED -I..\HARDWARE\Tim2 -I..\HARDWARE\IO -I"E:\TH\RTU\RTU开发程序\IAP-Bootloader V1.0\USER\RTE" -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_XL -DSTM32F10X_XHD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\usart.crf ..\SYSTEM\usart\usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _sys_exit PROC
;;;16     //定义_sys_exit()以避免使用半主机模式    
;;;17     void _sys_exit(int x) 
000000  bf00              NOP      
;;;18     { 
;;;19     	x = x; 
;;;20     } 
000002  4770              BX       lr
;;;21     //重定义fputc函数 
                          ENDP

                  fputc PROC
;;;22     int fputc(int ch, FILE *f)
000004  bf00              NOP      
                  |L1.6|
;;;23     {      
;;;24     	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
000006  4a37              LDR      r2,|L1.228|
000008  8812              LDRH     r2,[r2,#0]
00000a  f0020240          AND      r2,r2,#0x40
00000e  2a00              CMP      r2,#0
000010  d0f9              BEQ      |L1.6|
;;;25         USART1->DR = (u8) ch;      
000012  b2c2              UXTB     r2,r0
000014  4b33              LDR      r3,|L1.228|
000016  1d1b              ADDS     r3,r3,#4
000018  801a              STRH     r2,[r3,#0]
;;;26     	return ch;
;;;27     }
00001a  4770              BX       lr
;;;28     #endif 
                          ENDP

                  uart_init PROC
;;;40       
;;;41     void uart_init(u32 bound)
00001c  b510              PUSH     {r4,lr}
;;;42     {
00001e  b086              SUB      sp,sp,#0x18
000020  4604              MOV      r4,r0
;;;43       //GPIO端口设置
;;;44       GPIO_InitTypeDef GPIO_InitStructure;
;;;45     	USART_InitTypeDef USART_InitStructure;
;;;46     	NVIC_InitTypeDef NVIC_InitStructure;
;;;47     	 
;;;48     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);	//使能USART1，GPIOA时钟
000022  2101              MOVS     r1,#1
000024  f2440004          MOV      r0,#0x4004
000028  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;49       
;;;50     	//USART1_TX   GPIOA.9
;;;51       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9
00002c  f44f7000          MOV      r0,#0x200
000030  f8ad0014          STRH     r0,[sp,#0x14]
;;;52       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000034  2003              MOVS     r0,#3
000036  f88d0016          STRB     r0,[sp,#0x16]
;;;53       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
00003a  2018              MOVS     r0,#0x18
00003c  f88d0017          STRB     r0,[sp,#0x17]
;;;54       GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.9
000040  a905              ADD      r1,sp,#0x14
000042  4829              LDR      r0,|L1.232|
000044  f7fffffe          BL       GPIO_Init
;;;55        
;;;56       //USART1_RX	  GPIOA.10初始化
;;;57       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10
000048  f44f6080          MOV      r0,#0x400
00004c  f8ad0014          STRH     r0,[sp,#0x14]
;;;58       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
000050  2004              MOVS     r0,#4
000052  f88d0017          STRB     r0,[sp,#0x17]
;;;59       GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.10  
000056  a905              ADD      r1,sp,#0x14
000058  4823              LDR      r0,|L1.232|
00005a  f7fffffe          BL       GPIO_Init
;;;60     
;;;61       //Usart1 NVIC 配置
;;;62       NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
00005e  2025              MOVS     r0,#0x25
000060  f88d0000          STRB     r0,[sp,#0]
;;;63     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1;//抢占优先级3
000064  2001              MOVS     r0,#1
000066  f88d0001          STRB     r0,[sp,#1]
;;;64     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;		//子优先级3
00006a  f88d0002          STRB     r0,[sp,#2]
;;;65     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
00006e  f88d0003          STRB     r0,[sp,#3]
;;;66     	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
000072  4668              MOV      r0,sp
000074  f7fffffe          BL       NVIC_Init
;;;67       
;;;68        //USART 初始化设置
;;;69     
;;;70     	USART_InitStructure.USART_BaudRate = bound;//串口波特率
000078  9401              STR      r4,[sp,#4]
;;;71     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
00007a  2000              MOVS     r0,#0
00007c  f8ad0008          STRH     r0,[sp,#8]
;;;72     	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
000080  f8ad000a          STRH     r0,[sp,#0xa]
;;;73     	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
000084  f8ad000c          STRH     r0,[sp,#0xc]
;;;74     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
000088  f8ad0010          STRH     r0,[sp,#0x10]
;;;75     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
00008c  200c              MOVS     r0,#0xc
00008e  f8ad000e          STRH     r0,[sp,#0xe]
;;;76     
;;;77       USART_Init(USART1, &USART_InitStructure); //初始化串口1
000092  a901              ADD      r1,sp,#4
000094  4813              LDR      r0,|L1.228|
000096  f7fffffe          BL       USART_Init
;;;78       USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断
00009a  2201              MOVS     r2,#1
00009c  f2405125          MOV      r1,#0x525
0000a0  4810              LDR      r0,|L1.228|
0000a2  f7fffffe          BL       USART_ITConfig
;;;79       USART_Cmd(USART1, ENABLE);                    //使能串口1 
0000a6  2101              MOVS     r1,#1
0000a8  480e              LDR      r0,|L1.228|
0000aa  f7fffffe          BL       USART_Cmd
;;;80     
;;;81     }
0000ae  b006              ADD      sp,sp,#0x18
0000b0  bd10              POP      {r4,pc}
;;;82     
                          ENDP

                  USART1_IRQHandler PROC
;;;83     void USART1_IRQHandler(void)
0000b2  490c              LDR      r1,|L1.228|
;;;84     {
;;;85     	u8 res;	
;;;86     
;;;87     	if(USART1->SR&(1<<5))//接收到数据
0000b4  8809              LDRH     r1,[r1,#0]
0000b6  f0010120          AND      r1,r1,#0x20
0000ba  b189              CBZ      r1,|L1.224|
;;;88     	{	 
;;;89     		res=USART1->DR; 
0000bc  4909              LDR      r1,|L1.228|
0000be  1d09              ADDS     r1,r1,#4
0000c0  8809              LDRH     r1,[r1,#0]
0000c2  b2c8              UXTB     r0,r1
;;;90     		if(USART_RX_CNT < USART_REC_LEN)
0000c4  4909              LDR      r1,|L1.236|
0000c6  6809              LDR      r1,[r1,#0]  ; USART_RX_CNT
0000c8  f5b13faa          CMP      r1,#0x15400
0000cc  d208              BCS      |L1.224|
;;;91     		{
;;;92     			USART_RX_BUF[USART_RX_CNT]=res;
0000ce  4908              LDR      r1,|L1.240|
0000d0  4a06              LDR      r2,|L1.236|
0000d2  6812              LDR      r2,[r2,#0]  ; USART_RX_CNT
0000d4  5488              STRB     r0,[r1,r2]
;;;93     			USART_RX_CNT++;			 									     
0000d6  4905              LDR      r1,|L1.236|
0000d8  6809              LDR      r1,[r1,#0]  ; USART_RX_CNT
0000da  1c49              ADDS     r1,r1,#1
0000dc  4a03              LDR      r2,|L1.236|
0000de  6011              STR      r1,[r2,#0]  ; USART_RX_CNT
                  |L1.224|
;;;94     		}
;;;95     	}
;;;96     
;;;97     } 
0000e0  4770              BX       lr
;;;98     #endif	
                          ENDP

0000e2  0000              DCW      0x0000
                  |L1.228|
                          DCD      0x40013800
                  |L1.232|
                          DCD      0x40010800
                  |L1.236|
                          DCD      USART_RX_CNT
                  |L1.240|
                          DCD      USART_RX_BUF

                          AREA ||.ARM.__AT_0x20001000||, DATA, NOINIT, ALIGN=0

                  USART_RX_BUF
                          %        87040

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
                  USART_RX_STA
                          DCD      0x00000000
                  USART_RX_CNT
                          DCD      0x00000000
